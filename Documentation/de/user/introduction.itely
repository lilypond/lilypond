@c -*- coding: utf-8; mode: texinfo; -*-
@c This file is part of lilypond.tely
@ignore
    Translation of GIT committish: 8d678d320b2bef3d0ebfc737134d45bcec5e8a56

    When revising a translation, copy the HEAD committish of the
    version that you are working on.  See TRANSLATION for details.
@end ignore

@c \version "2.11.51"

@node Introduction
@chapter Introduction


@menu
* Engraving::                   
* Automated engraving::         
* What symbols to engrave?::    
* Music representation::        
* Example applications::        
* About the documentation::     
@end menu


@node Engraving
@section Engraving

Die Kunst des Notensatzes wird auch als Notenstich bezeichnet. Dieser 
Begriff stammt aus dem traditionellen Notendruck. Noch bis vor etwa 20 
Jahren wurden Noten erstellt, indem man sie in eine Zink- oder Zinnplatte 
schnitt oder mit Stempeln schlug. Diese Platte wurde dann mit Druckerschwärze
 versehen, so dass sie in den geschnittenen und gestempelten Vertiefungen 
blieb. Diese Vertiefungen schwärzten dann ein auf die Platte gelegtes 
Papier. Das Gravieren wurde vollständig von Hand erledigt. Es war darum 
sehr mühsam, Korrekturen anzubringen, weshalb man von vornherein richtig
 schneiden musste. Es handelte sich dabei um ein sehr spezialisiertes Handwerk.

Heutzutage wird fast alle gedruckte Musik von Computern erstellt. Das 
hat einige deutliche Vorteile: Drucke sind billiger als die gravierten
Platten und der Computersatz kann per E-Mail verschickt werden. Leider
hat der intensive Einsatz des Computers die graphische Qualität
des Notensatzes vermindert. Mit dem Computer erstellte Noten sehen 
langweilig und mechanisch aus, was es erschwert, von ihnen zu spielen.


@c introduce illustrating aspects of engraving, font...
Die Abbildung unten illustriert den Unterschied zwischen  
traditionellem Notensatz und einem typischen Computersatz. Das 
dritte Bild zeigt, wie LilyPond die Formen des traditionellen
Satzes nachahmt. Das linke Bild zeigt ein eingescanntes b-Vorzeichen 
aus einer 2000 herausgegebenen Edition. Das mittlere Bild
zeigt das b-Vorzeichen der selben Musik aus einer handgestochenen 
 Bärenreiter-Ausgabe. Das linke Bild zeigt die typischen Makel
des Computer-Satzes: Die Notenlinien sind sehr dünn, die Schwärze 
des Vorzeichens entspricht den dünnen Linien und hat eine gerade 
Form mit scharfen Ecken und Kanten. Im Gegensatz dazu hat das
Bärenreiter-Vorzeichen dicke, gerade zu sinnlich rundliche
Formen. Unser Symbol für das Vorzeichen hat neben anderen 
auch dieses b als Vorbild. Es ist abgerundet und passt zu unseren
Notenlinien, die sehr viel dicker sind als die der entsprechenden
Computer-Ausgabe.

@multitable @columnfractions .125 .25 .25 .25 .125
@item @tab
@ifnotinfo
@iftex
@image{henle-flat-gray,,4cm}
@end iftex
@ifnottex
@image{henle-flat-gray,,,png}
@end ifnottex

@tab
@iftex
@image{baer-flat-gray,,4cm}
@end iftex
@ifnottex
@image{baer-flat-gray,,,png}
@end ifnottex

@tab
@iftex
@image{lily-flat-bw,,4cm}
@end iftex
@ifnottex
@image{lily-flat-bw,,,png}
@end ifnottex
@end ifnotinfo
@ifinfo
@c workaround for makeinfo-4.6: line breaks and multi-column cookies
@image{henle-flat-bw,,,png} @image{baer-flat-bw,,,png}
@image{lily-flat-bw,,,png}
@end ifinfo

@item @tab
Henle (2000)
@tab
Bärenreiter (1950)
@tab
LilyPond Feta-Schriftart (2003)

@end multitable


@cindex Musiksymbole
@cindex Schriftart
@cindex Dichte
@cindex Balance

@c introduce illustrating aspects of engraving, spacing...
Die Verteilung der Noten innerhalb des Taktes sollte ihrer Dauer
entsprechen. Moderne Partituren zeigen diese Verhältnisse jedoch 
mit einer mathematischen Präzision, die nur sehr schlechte 
Ergebnisse bringt. Im nächsten Beispiel ist ein Motiv zweimal
gesetzt: einmal mit den exakten mathematischen Längenverhältnissen, dann
mit kleinen Korrekturen. Welches von beiden ist mit dieser Korrektur
gesetzt?

@cindex Optischer Ausgleich
@c file spacing-optical.
@c need to include it here,  because we want two images.
@lilypond
\paper {
  ragged-right = ##t
  indent = #0.0
}

music = {
   c'4 e''4 e'4 b'4 |
   \stemDown
   b'8[ e'' a' e'']
   \stemNeutral
   e'8[ e'8 e'8 e'8]
}

\score
{
  \music
  \layout {
    \context {
      \Staff
      \override NoteSpacing #'stem-spacing-correction = #0.6
    }
  }
}
@end lilypond

@lilypond
\paper {
  ragged-right = ##t
  indent = #0.0
}

music = {
   c'4 e''4 e'4 b'4 |
   \stemDown
   b'8[ e'' a' e'']
   \stemNeutral
   e'8[ e'8 e'8 e'8]
}
\score
{
  \music
  \layout {
    \context {
      \Staff
      \override NoteSpacing #'stem-spacing-correction = #0.0
      \override NoteSpacing #'same-direction-correction = #0.0
      \override StaffSpacing #'stem-spacing-correction = #0.0
    }
  }
}
@end lilypond

@cindex normale Rhythmen
@cindex normale Abstände

In diesem Ausschnitt kommen nur Viertel vor, Noten, die in einem
 gleichmäßigen Rhythmus gespielt werden. Die Abstände sollten das
 widerspiegeln. Leider lässt uns aber das Auge im Stich: es beachtet
 nicht nur den Abstand von aufeinander folgenden Notenköpfen, sondern
 auch den ihrer Hälse. Also müssen Noten, deren Hälse in direkter
 Folge zuerst nach oben und dann nach unten ausgerichtet sind, weiter
 auseinander gezogen werden, während die unten/oben-Folge engere
 Abstände fordert, und das alles auch noch in Abhängigkeit von der 
vertikalen Position der Noten. Das obere Beispiel ist mit dieser 
Korrektur gesetzt, das untere ohne. In letzterem Fall bilden sich 
für das Auge bei unten/oben-Folgen Notenklumpen mit schmalen Abständen 
zwischen den Notenhälsen.

@cindex Typographie

Musiker sind üblicherweise zu zu konzentriert, die Musik aufzuführen, 
als das Aussehen der Noten zu studieren; und diese 
Beschäftigung mit typographischen Details mag akademisch wirken. 
Das ist sie aber nicht. Unser Beispielstück hat einen 
monotonen Rhythmus, und wenn alle Zeilen gleich aussehen, wird 
das Notenblatt zu einem Labyrinth. Wenn der Spieler auch nur 
einmal wegschaut oder kurze Zeit unkonzentriert ist, findet er 
nicht mehr zurück zu der Stelle, an der er war.

Der dichtere Eindruck, den die dickeren Notenlinien und schwereren
Notationssymbole schaffen, eignet sich auch besser für Noten,
die weit vom Leser entfernt stehen, etwa auf einem Notenständer.
Eine sorgfältige Verteilung der Zwischenräume erlaubt es, die 
Noten sehr dicht zu setzen, ohne dass die Symbole zusammenklumpen. 
Dadurch werden unnötige Seitenumbrüche vermieden, sodass man 
nicht so oft blättern muss.

Dies sind die Anforderungen der Typographie: Das Layout sollte
schön sein -- nicht aus Selbstzweck, sondern um dem Leser zu helfen. Für 
Aufführungsmaterial ist das umso wichtiger, denn Musiker haben eine begrenzte
Aufmerksamkeit. Je weniger Mühe nötig ist, die Noten zu erfassen, desto mehr
Zeit bleibt für die Gestaltung der eigentlichen Musik. Das heißt: Gute 
Typographie führt zu besseren Aufführungen!

Die Beispiele haben gezeigt, dass der Notensatz eine subtile und 
komplexe Kunst ist und gute Ergebnisse nur mit viel Erfahrung 
erlangt werden können, die Musiker normalerweise nicht haben.
LilyPond stellt unser Bemühen dar, die graphische Qualität
handgestochener Notenseiten ins Computer-Zeitalter zu transportieren 
und sie für normale Musiker erreichbar zu machen. Wir haben 
unsere Algorithmen, die Gestalt der Symbole und die Programm-Einstellungen
darauf abgestimmt, einen Ausdruck zu erzielen, der der Qualität 
der alten Editionen entspricht, die wir so gerne betrachten 
und von denen wir gerne spielen.



@node Automated engraving
@section Automated engraving

Wie sollen wir also jetzt die Typographie anwenden?
Wie können wir erwarten, dass wir in der Lage wären, 
ein Programm zu schreiben, dass den Beruf des 
Notenstechers ersetzt, wo dieser doch mehr als zehn 
Jahre braucht, um ein Meister zu werden?

Wir können es tatsächlich nicht! Da Typographie allein 
durch das menschliche Auge bestimmt ist, kann der Mensch 
nicht ersetzt werden. Aber sehr viel mechanische Arbeit 
kann automatisiert werden. Indem etwa LilyPond die üblichen 
Situationen kennt und bewältigt, können die restlichen 
Fehler von Hand beseitigt werden. Das ist schon ein 
großer Fortschritt im Vergleich zu den existierenden 
Programmen. Und mit der Zeit können immer mehr Fälle 
automatisiert werden, so dass immer weniger Eingriffe 
von Hand notwendig werden.


Als wir anfingen, haben wir LilyPond vollständig in der Programmiersprache C++
geschrieben. Das hieß, dass der Funktionsumfang des Programms vollständig durch
die Programmierer festgelegt war. Das stellte sich aus einer Reihe von Gründen
als unzureichend heraus:

@itemize @bullet
@item Wenn LilyPond Fehler macht, muss der Benutzer die
Einstellungen ändern können. Er muss also Zugang zur 
Formatierungsmaschinerie haben. Deshalb können die Regeln und 
Einstellungen nicht beim Kompilieren des Programms festgelegt 
werden, sondern sie müssen während des Laufes zugänglich sein.


@item Notensatz ist eine Frage des Augenmaßes, und damit auch vom
 Geschmack abhängig. Benutzer können mit unseren Entscheidungen 
unzufrieden sein. Darum müssen also auch die Definitionen des 
typographischen Stils dem Benutzer zugänglich sein.

@item Schließlich verfeinern wir unseren Formatierungsalgorithmus 
immer weiter, also müssen die Regeln auch flexibel sein. Die
Sprache C++ zwingt zu einer bestimmten Gruppierungsmethode, 
die nicht den Regeln für den Notensatz entspricht.
@end itemize

Diese Probleme wurden angegangen, indem ein Übersetzer für 
die Programmiersprache Scheme integriert wurde und Teile
von LilyPond in Scheme neu geschrieben wurden. Die derzeitige 
Formatierungsarchitektur ist um die Notation von graphischen 
Objekten herum aufgebaut, die von Scheme-Variablen und -Funktionen
beschrieben werden. Diese Architektur umfasst Formatierungsregeln,
typographische Stile und individuelle Formatierungsentscheidungen. 
Der Benutzer hat direkten Zugang zu den meisten dieser Einstellungen.

Scheme-Variablen steuern Layout-Entscheidungen. Zum Beispiel haben 
viele graphische Objekte eine Richtungsvariable, die zwischen 
oben und unten (oder rechts und links) wählen kann. Hier etwa 
sind zwei Akkorde mit Akzenten und Arpeggien. 
Beim ersten Akkord sind alle Objekte nach unten (oder links)
 ausgerichtet, beim zweiten nach oben (rechts).

@lilypond[quote,ragged-right]
\new Score \with {
   \override SpacingSpanner #'spacing-increment = #3
   \override TimeSignature #'transparent = ##t
} \relative {
   \stemDown <e g b>4_>-\arpeggio
   \override Arpeggio #'direction = #RIGHT
   \stemUp <e g b>4^>-\arpeggio
}
@end lilypond

@noindent
Der Prozess des Notensetzens besteht für das Programm darin,
die Variablen der graphischen Objekte zu lesen und zu
schreiben. Einige Variablen haben festgelegte Werte. So 
ist etwa die Dicke von vielen Linien – ein Charakteristikum 
des typographischen Stils – von vornherein festgelegt. 
Wenn sie geändert werden, ergibt sich ein anderer typographischer Eindruck.

@lilypond[quote,ragged-right]
fragment = {
   \clef bass f8 as8
   c'4-~ c'16 as g f e16 g bes c' des'4
}
<<
   \new Staff \fragment
   \new Staff \with {
      \override Beam #'thickness = #0.3
      \override Stem #'thickness = #0.5
      \override Bar #'thickness = #3.6
      \override Tie #'thickness = #2.2
      \override StaffSymbol #'thickness = #3.0
      \override Tie #'extra-offset = #'(0 .  0.3)
      }
      \fragment
>>
@end lilypond

Formatierungsregeln sind auch vorbelegte Variablen. Zu jedem Objekt gehören
Variablen, die Prozeduren enthalten. Diese Prozeduren machen die eigentliche 
Satzarbeit, und wenn man sie durch andere ersetzt, kann die Darstellung 
von Objekten verändert werden. Im nächsten Beispiel wird die Regel, nach der 
die Notenköpfe gezeichnet werden, während des Ausschnitts verändert.

@lilypond[quote,ragged-right]
#(set-global-staff-size 30)

#(define (mc-squared grob orig current)
  (let* ((interfaces (ly:grob-interfaces grob))
         (pos (ly:grob-property grob 'staff-position)))
    (if (memq 'note-head-interface interfaces)
        (begin
          (ly:grob-set-property! grob 'stencil ly:text-interface::print)
          (ly:grob-set-property! grob 'font-family 'roman)
          (ly:grob-set-property! grob 'text
            (make-raise-markup -0.5
              (case pos
                ((-5) (make-simple-markup "m"))
                ((-3) (make-simple-markup "c "))
                ((-2) (make-smaller-markup (make-bold-markup "2")))
                (else (make-simple-markup "bla")))))))))

\new Voice \relative c' {
   \stemUp
   \set autoBeaming = ##f
   \time 2/4
   <d f g>4
   \once \override NoteHead #'stencil = #ly:note-head::brew-ez-stencil
   \once \override NoteHead #'font-size = #-7
   \once \override NoteHead #'font-family = #'sans
   \once \override NoteHead #'font-series = #'bold
   <d f g>
   \once \override NoteHead #'style = #'cross
   <d f g>
   \applyOutput #'Voice #mc-squared
   <d f g>
   <<
      { d8[ es-( fis^^ g] fis2-) }
      \repeat unfold 5 { \applyOutput #'Voice #mc-squared s8 }
   >>
}
@end lilypond



@node What symbols to engrave?
@section What symbols to engrave?

@cindex Notensatz
@cindex Typographie

Während des Notensatzprozesses entscheidet sich, wo
Symbole platziert werden. Das kann aber nur gelingen, 
wenn vorher entschieden wird, @emph{welche} Symbole
gesetzt werden sollen, also welche Notation benutzt
werden soll.

Die heutige Notation ist ein System zur Musikaufzeichnung,
das sich über die letzten 1000 Jahre entwickelt hat. Die 
Form, die heute üblicherweise benutzt wird, stammt aus dem 
frühen Barock. Auch wenn sich die grundlegenden Formen (also
die Notenköpfe, das Fünfliniensystem) nicht verändert haben, 
entwickeln sich die Details trotzdem immer noch weiter, um 
die Errungenschaften der Neuen Musik darstellen zu können. Die 
Notation umfasst also 500 Jahre Musikgeschichte. Ihre Anwendung 
reicht von monophonen Melodien bis zu ungeheurem Kontrapunkt 
für großes Orchester.

Wie bekommen wir dieses vielköpfige Monster zu fassen? 
Unsere Lösung ist es, eine strikte Trennung zwischen der Notation, 
also welche Symbole benutzt werden, und dem Satz, also wohin sie 
gesetzt werden, zu machen. Um das Problem anzupacken, haben wir 
es in kleine (programmierbare) Happen zerteilt, so dass jede Art 
von Symbol durch ein eigenes Plugin verarbeitet wird. Alle Plugins
 kooperieren durch die LilyPond-Architektur. Sie sind vollständig 
modular und unabhängig und können somit auch unabhängig voneinander
 entwickelt werden. Der Schreiber, der die Musik in Graphik umwandelt,
 ist ein Kopist oder Notenstecher (engl. engraver). Darum werden 
die Plugins  als @code{engraver} bezeichnet.

Im nächsten Beispiel wird gezeigt, wie mit dem Plugin für die Notenköpfe, 
dem @code{Note_heads_engraver} (@qq{Notenkopfstecher}) der Satz begonnen wird.

@lilypond[quote,ragged-right]
\include "engraver-example.ily"

\score {
   \topVoice
   \layout {
   \context {
      \Voice
      \remove "Stem_engraver"
      \remove "Phrasing_slur_engraver"
      \remove "Slur_engraver"
      \remove "Script_engraver"
      \remove "Beam_engraver"
      \remove "Auto_beam_engraver"
   }
   \context {
      \Staff
      \remove "Accidental_engraver"
      \remove "Key_engraver"
      \remove "Clef_engraver"
      \remove "Bar_engraver"
      \remove "Time_signature_engraver"
      \remove "Staff_symbol_engraver"
      \consists "Pitch_squash_engraver"
   }
}
}
@end lilypond

@noindent
Dann fügt ein @code{Staff_symbol_engraver} (@qq{Notensystemstecher}) 
die Notenlinien hinzu.

@lilypond[quote,ragged-right]
\include "engraver-example.ily"

\score {
  \topVoice
  \layout {
    \context {
      \Voice
      \remove "Stem_engraver"
      \remove "Phrasing_slur_engraver"
      \remove "Slur_engraver"
      \remove "Script_engraver"
      \remove "Beam_engraver"
      \remove "Auto_beam_engraver"
    }
    \context {
      \Staff
      \remove "Accidental_engraver"
      \remove "Key_engraver"
      \remove "Clef_engraver"
      \remove "Bar_engraver"
      \consists "Pitch_squash_engraver"
      \remove "Time_signature_engraver"
    }
  }
}
@end lilypond

@noindent
Der @code{Clef_engraver} (@qq{Notenschlüsselstecher}) definiert 
eine Referenzstelle für das System.

@lilypond[quote,ragged-right]
\include "engraver-example.ily"

\score {
  \topVoice
  \layout {
    \context {
      \Voice
      \remove "Stem_engraver"
      \remove "Phrasing_slur_engraver"
      \remove "Slur_engraver"
      \remove "Script_engraver"
      \remove "Beam_engraver"
      \remove "Auto_beam_engraver"
    }
    \context {
      \Staff
      \remove "Accidental_engraver"
      \remove "Key_engraver"
      \remove "Bar_engraver"
      \remove "Time_signature_engraver"
    }
  }
}
@end lilypond

@noindent
Der @code{Stem_engraver} (@qq{Halsstecher}) schließlich fügt
 Hälse hinzu.

@lilypond[quote,ragged-right]
\include "engraver-example.ily"

\score {
  \topVoice
  \layout {
    \context {
      \Voice
      \remove "Phrasing_slur_engraver"
      \remove "Slur_engraver"
      \remove "Script_engraver"
      \remove "Beam_engraver"
      \remove "Auto_beam_engraver"
    }
    \context {
      \Staff
      \remove "Accidental_engraver"
      \remove "Key_engraver"
      \remove "Bar_engraver"
      \remove "Time_signature_engraver"
    }
  }
}
@end lilypond

@noindent
Dem @code{Stem_engraver} wird jeder Notenkopf mitgeteilt, 
der vorkommt. Jedes Mal, wenn ein Notenkopf erscheint (oder mehrere bei 
einem Akkord), wird ein Hals-Objekt erstellt und an den 
Kopf geheftet. Wenn wir dann noch engraver für Balken, Bögen, 
Akzente, Vorzeichen, Taktlinien, Taktangaben und Tonartbezeichnungen 
hinzufügen, erhalten wir eine vollständige Notation.


@lilypond[quote,ragged-right]
\include "engraver-example.ily"
\score { \topVoice }
@end lilypond

Dieses System funktioniert gut für monophone Musik, aber wie geht 
es mit Polyphonie? Hier müssen sich mehrere Stimmen ein System teilen.

@lilypond[quote,ragged-right]
\include "engraver-example.ily"
\new Staff << \topVoice \\ \botVoice >>
@end lilypond

In diesem Fall benutzen beide Stimmen das System und die Vorzeichen gemeinsam,
aber die 
Hälse, Bögen, Balken usw. sind jeder einzelnen Stimme eigen. Die engraver 
müssen also gruppiert werden. Die Köpfe, Hälse, Bögen usw. werden 
in einer Gruppe mit dem Namen @qq{Voice context} (Stimmenkontext) 
zusammengefasst, die engraver für den Schlüssel, die Vorzeichen, 
Taktstriche usw. dagegen in einer Gruppe mit dem Namen @qq{Staff context} 
(Systemkontext). Im Falle von Polyphonie hat ein Staff-Kontext dann also 
mehr als nur einen Voice-Kontext. Auf gleiche Weise können auch mehrere Staff-Kontexte
in einen großen Score-Kontext (Partiturkontext) eingebunden werden.

@seealso

Programmreferenz: @rinternals{Contexts}.

@lilypond[quote,ragged-right]
\include "engraver-example.ily"
\score {
   <<
      \new Staff << \topVoice \\ \botVoice >>
      \new Staff << \pah \\ \hoom >>
   >>
}
@end lilypond

@node Music representation
@section Music representation

Idealerweise ist das Eingabeformat für ein höheres Satzsystem die 
abstrakte Beschreibung des Inhaltes. In diesem Fall wäre das die 
Musik selber. Das stellt uns aber vor ein ziemlich großes Problem, 
denn wie können wir definieren, was Musik wirklich ist? Anstatt darauf 
eine Antwort zu suchen, haben wir die Frage einfach umgedreht. Wir
schreiben ein Programm, das den Notensatz beherrscht und passen das 
Format an, so einfach wie möglich zu sein. Wenn es nicht mehr vereinfacht 
werden kann, haben wir per Definition nur noch den reinen Inhalt. Unser 
Format dient als die formale Definition eines Musiktextes.

Die Syntax ist gleichzeitig die Benutzerschnittstelle bei LilyPond, 
darum soll sie einfach zu schreiben sein; z. B. bedeutet

@example
c'4 d'8
@end example

@noindent
eine Viertel c' und eine Achtel d', wie in diesem Beispiel:

@lilypond[quote]
{
  c'4 d'8
}
@end lilypond

In kleinem Rahmen ist diese Syntax sehr einfach zu benutzen. In 
größeren Zusammenhängen aber brauchen wir Struktur. Wie sonst kann 
man große Opern oder Symphonien notieren? Diese Struktur wird 
gewährleistet durch sog. music expressions (Musikausdrücke): indem 
kleine Teile zu größeren kombiniert werden, kann komplexere Musik 
dargestellt werden. So etwa hier:

@lilypond[quote,verbatim,fragment,relative=1]
c4
@end lilypond

@noindent
Gleichzeitig erklingende Noten werden hinzugefügt, indem man alle in << und >> einschließt.

@c < > is not a music expression,
@c so we use <<>> iso. <> to drive home the point of
@c expressions.  Don't change this back --hwn.
@example
<<c4 d4 e4>>
@end example

@lilypond[quote,fragment,relative=1]
\new Voice { <<c4 d4 e>> }
@end lilypond

@noindent
Um aufeinanderfolgende Noten darzustellen, werden sie in geschweifte Klammern gefasst:

@code{@{@tie{}@dots{}@tie{}@}}

@example
@{ f4 <<c4 d4 e4>> @}
@end example

@lilypond[quote,relative=1,fragment]
{ f4 <<c d e4>> }
@end lilypond

@noindent
Dieses Gebilde ist in sich wieder ein Ausdruck, und kann 
daher mit einem anderen Ausdruck kombiniert werden (hier mit einer Halben).

@example
<< g2 \\ @{ f4 <<c4 d4 e4>> @} >>
@end example

@lilypond[quote,fragment,relative=2]
\new Voice { << g2 \\ { f4 <<c d e>> } >> }
@end lilypond

Solche geschachtelten Strukturen können sehr gut in einer 
kontextunabhängigen Grammatik beschrieben werden. Der Programmcode 
für den Satz ist auch mit solch einer Grammatik erstellt. Die Syntax 
von LilyPond ist also klar und ohne Zweideutigkeiten definiert.

Die Benutzerschnittstelle und die Syntax werden als erstes vom Benutzer 
wahrgenommen. Teilweise sind sie eine Frage des Geschmackes und werden viel
diskutiert. Auch wenn Geschmacksfragen ihre Berechtigung 
haben, sind sie nicht sehr produktiv. Im großen Rahmen von LilyPond 
spielt die Eingabe-Syntax nur eine geringe Rolle, denn eine logische 
Syntax zu schreiben ist einfach, guten Formatierungscode aber sehr viel 
schwieriger. Das kann auch die Zeilenzahl der Programmzeilen zeigen: 
Analysieren und Darstellen nimmt nur etwa 10% des Codes ein:

@node Example applications
@section Example applications

Wir haben LilyPond als einen Versuch geschrieben, wie man die Kunst des 
Musiksatzes in ein Computerprogramm gießen kann. Dieses 
Programm kann nun dank vieler harter Arbeitsstunden benutzt werden, 
um sinnvolle Aufgaben zu erledigen. Die einfachste ist dabei der 
Notendruck.

@lilypond[quote,relative=1]
{
  \time 2/4
  c4 c g'4 g a4 a g2
}
@end lilypond

@noindent
Indem wir Akkordsymbole und einen Text hinzufügen, erhalten wir 
ein Lead Sheet.

@lilypond[quote,ragged-right]
<<
   \chords { c2 c f2 c }
   \new Staff \relative c' { \time 2/4 c4 c g'4 g a4 a g2 }
   \new Lyrics \lyricmode { twin4 kle twin kle lit tle star2 }
>>
@end lilypond

Mehrstimmige Notation und Klaviermusik kann auch gesetzt werden. Das 
nächste Beispiel zeigt einige etwas exotischere Konstruktionen:

@lilypondfile[quote,ragged-right]{screech-boink.ly}

Die obenstehenden Beispiele wurde manuell erstellt, aber das ist nicht 
die einzige Möglichkeit. Da der Satz fast vollständig automatisch abläuft, 
kann er auch von anderen Programmen angesteuert werden, die Musik oder Noten
verarbeiten. So können etwa ganze Datenbanken musikalischer Fragmente automatisch 
in Notenbilder umgewandelt werden, die dann auf Internetseiten oder 
in Multimediapräsentation Anwendung finden.

Dieses Benutzerhandbuch zeigt eine weitere Möglichkeit: Die Noten werden als 
reiner Text eingegeben und können darum sehr einfach integriert werden
in andere textbasierte Formate wie etwa @LaTeX{}, HTML oder, wie in diesem 
Fall, Texinfo. Durch ein spezielles Programm werden die Eingabefragmente durch 
Notenbilder in der resultierenden PDF- oder HTML-Datei ersetzt. Dadurch ist
es sehr einfach, Noten und Text zu kombinieren.



@node About the documentation
@section About the documentation

Es gibt zwei Handbücher zu LilyPond: das @emph{Benutzerhandbuch} (dieses 
Dokument) und das @emph{Handbuch über die Programmbenutzung}.


@subheading User manual

Das Handbuch ist in drei Bücher geteilt.

@subsubheading Learning manual

In diesem Buch wird erklärt, wie man das Programm LilyPond erlernt; mit 
einfachen Begriffen werden einige Schlüsselkonzepte erklärt. Die Kapitel 
sollten hintereinander gelesen werden.

@c we need to completely rewrite this once GDP is finished.  -gp
@ignore
@itemize @bullet

@item
@ifhtml
Die 
@end ifhtml
@emph{@ref{Tutorial}},
stellt eine einfache Einführung in den Musiksatz dar. Neulinge sollten hiermit 
beginnen.

@item
@emph{@ref{Fundamental concepts}},
erklärt generelle Konzepte des LilyPond-Dateiformates. Wenn Sie sich nicht 
sicher sind, wohin ein Befehl gesetzt werden soll, lesen Sie hier nach.

@item
@emph{@ref{Working on LilyPond projects}},
zeigt den wirklichen Einsatz von LilyPond und gibt Hinweise, wie einige 
Probleme vermieden werden können.

@item
@emph{@ref{Tweaking output}},
stellt dar, wie die Standardeinstellungen von LilyPond verändert werden können.
 
@end itemize


@subsubheading Notation reference

In diesem Buch werden alle LilyPond-Befehle erklärt, die Notationszeichen 
produzieren. Es geht von der Annahme aus, dass der Leser sich mit den 
Grundkonzeption des Programmes im Handbuch zum Lernen bekannt gemacht hat.

@itemize @bullet

@item
@emph{@ruser{Musical notation}},
erklärt alles über die grundlegenden Notationskonstruktionen. Dieses Kapitel 
ist für fast jedes Notationsprojekt nützlich.

@item
@emph{@ruser{Specialist notation}},
erklärt spezifische Schwierigkeiten, die sich bei bestimmten Notationstypen 
ergeben. Dieses Kapitel ist nur in entsprechenden Fällen bestimmter Instrumente 
oder bei Gesang zu konsultieren.

@item
@emph{@ruser{Changing defaults}},
erklärt, wie des Layout getrimmt werden kann.

@item
@emph{@ruser{Non-musical notation}},
zeigt alles, was nicht direkt mit den Noten zu tun hat wie Titel, mehrere Sätze oder 
wie man ein MIDI-Instrument auswählt.

@item
@emph{@ruser{Spacing issues}},
befasst sich mit globalen Fragen wie der Definition von Papierformaten 
oder wie man Seitenumbrüche definiert.

@item
@emph{@ruser{Interfaces for programmers}},
demonstriert die Erstellung von musikalischen Funktionen.

@end itemize


@subsubheading Appendices

In diesem Buch werden nützliche Referenztabellen gezeigt.

@itemize @bullet
@item
@ifhtml
Die
@end ifhtml
@emph{@ruser{Literature list}},
enthält einige wichtige Quellen für alle, die mehr über Notation und 
den Notensatz erfahren wollen.

@item
Die 
@emph{@ref{Scheme tutorial}},
stellt eine kurze Einleitung in die Scheme-Sprache dar, mit dem 
die musikalischen Funktionen gebildet werden.

@item
@emph{@ruser{Notation manual tables}},
sind Tabellen, in denen Akkordbezeichnungen, MIDI-Instrumente, 
Farbbezeichnungen und die Zeichen der Feta-Schriftart gesammelt sind.

@item
@emph{@ref{Templates}},
von LilyPond-Stücken. Kopieren Sie einfach hier, fügen Sie in ihre Datei 
ein und schreiben Sie noch die Noten dazu. Das ist alles!

@item
Die
@emph{@ruser{Cheat sheet}},
zeigt die wichtigsten LilyPond-Befehle.

@item
Der
@emph{@ruser{LilyPond command index}},
listet alle Befehle auf, die mit @code{\} anfangen.

@item
Der 
@emph{@ref{LilyPond index}},
ist ein vollständiger Index.

@end itemize
@end ignore


@subheading Program usage

In diesem Buch wird erklärt, wie das Programm ausgeführt wird und 
wie die Notation von LilyPond in andere Programme integriert werden 
kann.

@itemize @bullet

@item
@emph{@rprogram{Install}},
erklärt wie LilyPond installiert wird (inklusive Kompilation, wenn es 
nötig sein sollte).

@item
@emph{@rprogram{Setup}},
erklärt wie der Computer eingerichtet wird, damit LilyPond optimal genutzt 
werden kann. Hierzu gehören etwa spezielle Umgebungen für bestimmte 
Texteditoren.

@item
@emph{@rprogram{Running LilyPond}},
zeigt, wie LilyPond und seine Hilfsprogramme gestartet werden. Zusätzlich 
wird hier erklärt, wie Quelldateien von alten LilyPond-Versionen aktualisiert 
werden können.

@item
@emph{@rprogram{LilyPond-book}},
erklärt die Details, um einen Text mit eingefügten Notenbeispielen (wie 
etwa dieses Handbuch) zu 
erstellen.

@item
@emph{@rprogram{Converting from other formats}},
erklärt, wie die Konvertierungsprogramme aufgerufen werden. Diese 
Programme kommen mit LilyPond zusammen und konvertieren eine Vielzahl 
von Notensatzformaten in das @code{.ly}-Format.

@end itemize


@subsubheading Other information

Es gibt einige andere Orte, die sehr wertvolle Information enthalten.
@itemize @bullet
@cindex Dialekt
@cindex Jargon
@cindex Terminologie
@cindex Fremdsprache
@cindex Sprache
@cindex Englische Begriffe

@item
@ifnottex
Das @ref{Top,Musik-Glossar,,music-glossary}, erklärt musikalische Ausdrücke 
und stellt Übersetzungen für einige Sprachen bereit. Es ist auch als PDF 
erhältlich.
@end ifnottex
@iftex
Das Musik-Glossar erklärt musikalische Ausdrücke 
und stellt Übersetzungen für einige Sprachen bereit. Es ist auch als PDF 
erhältlich.
@end iftex
Wenn Sie sich mit der Notation von Musik nicht auskennen (und besonders, 
wenn Englisch nicht Ihre Muttersprache ist), wird dieses Glossar von 
großer Hilfe sein.
 
@cindex Schnipsel
@cindex LSR
@item
Die @rlsrnamed{Top,Schnipsel} sind eine ausführliche Sammlung kurzer Beispiele, anhand derer Tricks, 
Tipps und Spezialfunktionen von LilyPond demonstriert werden. Die meisten 
dieser Schnipsel können auch im 
 @uref{http://lsr.dsi.unimi.it/,LilyPond Schnipsel
Depot} betrachtet werden. Diese Internetseite verfügt auch über ein 
durchsuchbares LilyPond-Handbuch.


@item
Die
@iftex
Programmreferenz
@end iftex
@ifnottex
@ref{Top,Programmreferenz,,lilypond-internals}
@end ifnottex
ist eine Sammlung intensiv verlinkter HTML-Seiten,
die alle Details jeder einzelnen LilyPond-Klasse, jedes Objektes und 
jeder Funktion erklären. Sie wird direkt aus den Satzdefinitionen 
produziert.

So gut wie alle Formatierungsmöglichkeiten, die intern verwendet werden, 
sind auch direkt für den Benutzer zugänglich. Alle Variablen z. B., die
Dicke-Werte, Entfernungen usw. kontrollieren, können in den Eingabe-Dateien 
verändert werden. Es gibt eine riesige Anzahl von Formatierungsoptionen, und 
alle haben einen @qq{Siehe}-Abschnitt, der auf die Dokumentation verweist.
Im HTML-Handbuch haben diese Abschnitte klickbare Links.

Die Programmreferenz ist nur auf englisch erhältlich.


@end itemize

Wenn Sie schon ein erfahrener Benutzer sind, können Sie dieses Handbuch 
als Referenz benutzen: Es enthält einen ausführlichen Index@footnote{Wenn
Sie nach etwas suchen und es nicht im Handbuch finden, so gilt das als Fehler. 
Bitte schicken Sie in diesem Fall einen Fehlerbericht.}, aber das Dokument 
ist auch als
@iftex
große HTML-Seite erhältlich,
@end iftex
@ifhtml
@uref{source/Documentation/user/lilypond-big-page.html, eine große Seite 
erhältlich},
@end ifhtml
die auf einfache Art mit der Suchfunktion Ihres Browsers durchsucht werden kann.

Auf allen HTML-Seiten, die Noten eingebettet haben, deren Ausgabe mit LilyPond 
vorgenommen wurde, kann die originale Quelldatei durch einen Klick auf das 
Bild betrachtet werden.

Der Speicherort der Dokumentationsdateien unterscheidet sich evtl. je 
nach Betriebssystem. Manchmal wird hier auf Initialisierungs- oder 
Beispieldateien verwiesen. Das Handbuch nimmt dabei an, dass diese 
Dateien sich relativ zum Quellverzeichnis befinden. Zum Beispiel würde 
der Pfad @file{input/@/lsr/@/Verzeichnis/@/bla@/.ly} etwa auf die Datei 
@file{lilypond@/2.x.y/@/input/@/lsr/@/Verzeichnis/@/bla@/.ly} verweisen. In den 
Binärpaketen für Unix-Plattformen sind Dokumentation und Beispiele 
üblicherweise in einem Verzeichnis wie @file{/usr/@/share/@/doc/@/lilypond/}
gespeichert. Initialisierungsdateien, etwa  @file{scm/@/lily@/.scm}, 
oder @file{ly/@/engraver@/-init@/.ly}, befinden sich normalerweise im 
Verzeichnis @file{/usr/@/share/@/lilypond/}.

@cindex Anpassen der Ausgabe
@cindex Variablen
@cindex Eigenschaften
@cindex properties
@cindex lilypond-internals
@cindex interne Dokumentation
@cindex Scheme
@cindex Erweiterung von LilyPond
@cindex Index

Dieses Handbuch (so wie alle anderen) ist als PDF- oder HTML-Datei von 
LilyPonds Internetseite @uref{http://@/www@/.lilypond@/.org/} herunterladbar.
